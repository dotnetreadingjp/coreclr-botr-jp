型システム概要
====================
(これは https://github.com/dotnet/coreclr/blob/master/Documentation/botr/type-system.md の日本語訳です。対象rev.は 1ed2739）

Author: David Wrighton ([@davidwrighton](https://github.com/davidwrighton)) - 2010

はじめに
============

CLRの型システムは、ECMA仕様とその拡張で説明されている型システムを私たちが表現したものです。（訳注：以下、CLRの型システムのことを単に「型システム」と表記します。）

概要
--------

型システムは一連のデータ構造から成ります。
それらの一部は、Book of the Runtimeの別のチャプターで説明されています。
また、データ構造を操作したり生成したりするアルゴリズムの集合も同様に型システムの一部です。
リフレクションによって公開されるものは、型システムに依存してはいますが、型システムでは**ありません**。

型システムによって保持されている主要なデータ構造は以下のものです。

- MethodTable
- EEClass
- MethodDesc
- FieldDesc
- TypeDesc
- ClassLoader

型システムに含まれる主要なアルゴリズムは以下のものです。

- **タイプローダー:** 型をロードします。また、型システムの主要なデータ構造のほとんどを生成します。
- **CanCastTo およびそれに類するもの:** 型を比較する機能です。
- **LoadTypeHandle:** 主に型を探し出すために使用されます。
- **シグネチャー解析:** メソッドとフィールドに関する情報を集めて比較するために使用されます。
- **GetMethod/FieldDesc:** メソッドとフィールドを探し出してロードするために使用されます。
- **仮想スタブディスパッチ:** インターフェースに対する仮想呼び出しの対象を探し出すために使用されます。

これらの他にも、付随するデータ構造やアルゴリズムがたくさん存在しています。
それらはCLRの他の部分に関する多くの情報を提供するものなのですが、
型システム全体の理解のためにはそれほど重要ではありません。

コンポーネント アーキテクチャ
----------------------

型システムのデータ構造群は、さまざまなアルゴリズムの全体で広く使われています。
本ドキュメントは型システムのアルゴリズム群を説明するものではありません（なぜなら、そのためには他のBotRドキュメントがあるべきですし、一部はすでに存在しているからです）が、よく使われるさまざまなデータ構造については以降で説明しようとしています。

依存関係
------------

大まかには、型システムとはCLRの各部分に対して提供される1つのサービスで、型システムの振る舞いに関する主要なコンポーネントのほとんどはある種の依存関係を構成しています。
この図は型システムに影響する全体的なデータの流れを説明したものです。
包括的なものではありませんが、重要な情報の流れを抜き出しています。

![dependencies](https://raw.githubusercontent.com/dotnet/coreclr/09ad260f28df803cf288cecd5aa681c81f7bfa13/Documentation/images/type-system-dependencies.png)

### 型システムの依存コンポーネント

型システムが依存する主要なコンポーネントは以下のものです。

- **ローダー** は、動作する上で正しいメタデータを得るために必要とされます。
- **メタデータシステム** は、情報を集めるためのメタデータAPIを提供します。
- **セキュリティシステム** は、ある特定の型システムのデータ構造（e.g. 継承）が許されるかどうかを型システムに通知します。
- **AppDomain** は、型システムのデータ構造に関するアロケーションの振る舞いを操作するためのLoaderAllocatorを提供します。

### 型システムに依存しているコンポーネント

3つの主要なコンポーネントが型システムに依存しています。

- **JIT インターフェース**およびJIT ヘルパー群は、主に型、メソッド、およびフィールドの検索機構に依存します。型システムのオブジェクトが見つかった時点で、返されるデータ構造はJITに必要な情報を提供するよう調整されます。
- **リフレクション** は型システムを使用して、ECMAで標準化された概念への比較的簡潔なアクセスを提供します。その概念は偶然にもわれわれがCLRの型システムが持つデータ構造に保存していたものです。
- **一般的なマネージドコードの実行**には、型システムの利用が必要です。それは、型の比較ロジックや仮想スタブディスパッチのためです。

型システムの設計
=====================

型システムの中心的なデータ構造は、実際にロードされた型を表現するデータ構造（e.g. TypeHandle, MethodTable, MethodDesc, TypeDesc, EEClass）と、すでにロードされた型を見つけられるようにするデータ構造（e.g. ClassLoader, アセンブリ, モジュール, RIDMaps）です。

型のロードに関連するデータ構造とアルゴリズムは、Book of the Runtimeの[タイプローダー](type-loader.md)と[MethodDesc](method-descriptor.md)のチャプターで論じられています。

これらのデータ構造を束ねる機能の集合によって、JIT/リフレクション/タイプローダー/スタックウォーカーは既存の型やメソッドを見つけ出すことができます。
概要を説明すると、それらの検索はECMA CLI仕様に規定されているメタデータトークンやシグネチャによって容易に動作するものであるべきだということです。

そして最後に、型システムの適切なデータ構造が見つかったときは、型から情報を集めたり、2つの型を比較したりするアルゴリズムがあります。
この場合のアルゴリズムとして特に複雑な例が、Book of the Runtimeの[仮想スタブディスパッチ](virtual-stub-dispatch.md)のチャプターにあるでしょう。

設計上の目標と目標ではないもの
--------------------------

### 目標

- 実行中の（リフレクションでない）コードからの、実行時に必要な情報へのアクセスが高速なこと。
- コード生成のための、コンパイル時に必要な情報へのアクセスが容易であること。
- ガベージコレクタ/スタックウォーカーが必要な情報へアクセスする時に、ロックを取ったりメモリを割り当てたりしなくてよいこと。
- 一度にロードされる型が最小限であること。
- 指定された型のロード時に、ロードする量が最小限であること。
- 型システムのデータ構造をNGENのイメージに必ず保存できること。

### 目標ではないもの

- メタデータ中のすべての情報がCLRのデータ構造を直接反映していること。
- リフレクションのすべての操作が高速であること。

マネージドコードを実行するために実行時に使用される典型的なアルゴリズムの設計
------------------------------------------------------------------------------

型システムのアルゴリズムの典型例はキャスト（型変換）アルゴリズムです。これはマネージドコードの実行中に多用されています。

このアルゴリズムには4つ以上のエントリーポイントがあります。
個々のエントリーポイントは、高速な実行経路としてそれぞれ違ったものを提供するように選ばれています。
それによって、できる限り最高の性能を引き出すことを目指しています。

<!-- a particular non-type equivalent non-array type の意味が取れていない。 -->
- あるオブジェクトは、特定の、型に互換性のない非配列型にキャスト可能か？
- あるオブジェクトは、ジェネリックな変性を実装していないインターフェース型にキャスト可能か？
- あるオブジェクトは、配列型にキャスト可能か？
- ある型のオブジェクトは、別の任意のマネージド型にキャスト可能か？

それぞれの実装は、最後のものをを除いて、完全には一般化しない代わりに高速に動作するよう最適化されています。

たとえば、「ある型は、その親の型にキャスト可能か？」は「あるオブジェクトは、特定の、型に互換性のない非配列型にキャスト可能か？」のバリエーションですが、コードは片方向連結リストをたどる一重ループとして実装されています。
これはあり得るキャスト操作の一部分でしか検索できませんが、変換しようとしている先の型について調査することで、適切な集合であるかを決定することはできます。
このアルゴリズムはJITヘルパーの `JIT_ChkCastClass_Portable` に実装されています。

仮定:

- 特殊用途のアルゴリズム実装は、一般にパフォーマンスを改善します。
- アルゴリズムの追加版は、克服不可能な保守性の問題を生みません。

型システムが持つ典型的な検索アルゴリズムの設計
-----------------------------------------------------

型システムの持つアルゴリズムには、この共通的なパターンに従ったものがいくつもあります。

型システムは型を見つけ出すために通常使われますが、それはJITやリフレクションやシリアル化やリモーティングなど、さまざまな入力をきっかけとして開始される可能性があります。

そういったケースにおいて、型システムへの基本的な入力は以下のものです。

- 検索の開始点となるべきであるコンテキスト（モジュールまたはアセンブリのポインター）。
- 当初のコンテキストにおいて、求められている型を説明する識別子。これは通常はトークンまたは文字列（検索のコンテキストがアセンブリの場合）です。

検索アルゴリズムはまず最初に識別子を解読しなければなりません。

ある型を検索するシナリオにおいてトークンとなるのは、TypeDefトークン、TypeRefトークン、TypeSpecトークン、文字列のどれかです。
これらの異なった識別子は、それぞれ別の形の探索を開始させます。

- **typedef トークン** は、モジュールのRidMapから探索を開始させます。これは単純な配列のインデックスです。
- **typeref トークン** は、このtyperefトークンが参照するアセンブリを見つける探索を開始させます。その後、見つかったアセンブリのポインターと、typerefテーブルから取り出した文字列とを使った型検索アルゴリズムが新たに開始します。
- **typespec トークン** は、型のシグネチャを得るために他のシグネチャをパースしなければならないことを示します。シグネチャをパースすることで型をロードするために不可欠な情報を得るのですが、それによってさらに別の型探索が再帰的に開始されることになります。
- **名前** は複数のアセンブリを結びつけるために使用されます。TypeDef/ExportedTypesテーブルが検索され、一致するか判定されます。メモ：この検索は、マニフェストモジュールオブジェクトのハッシュテーブルに最適化されています。

この設計によって、型システムにおける検索アルゴリズムの共通的な特色がいくつも明らかになりました。

- 検索は、メタデータと密結合している入力を使用します。中でも、通常はメタデータトークンや名前の文字列が渡されていきます。また、これらの検索はモジュールと結びついています。モジュールは.dllおよび.exeファイルと直接対応するものです。
- パフォーマンスを改善するためにキャッシュされた情報を利用します。RidMapやハッシュテーブルは、 それらの探索効率を改善するように最適化されています。
- 検索アルゴリズムは、入力に基づいた異なる経路を3つか4つ持っているのが一般的です。

以上の一般的な設計に加えて、いくつもの追加要求が積み重ねられています。

- **仮定:** すでにロードされた型の検索は、GCによる停止中に実行しても安全であること。
- **不変条件:** いったんロードが完了した型は、再度検索しても必ず見つかること。
- **課題:** 検索ルーチンがメタデータの読み取りに頼っていること。このことによって十分な性能が得られないようなシナリオもありえます。

この検索アルゴリズムはJIT中に呼び出されるルーチンに典型的で、共通的な特徴がいくつもあります。

- メタデータを使用します。
- 様々な場所にあるデータを探すことが要求されます。
- データ構造内のデータには重複が比較的少ないです。
- 通常は深く再帰しませんし、ループも持ちません。

<!-- meet characteristics の意味が取れていない。 -->
このことで性能要求を満たすことができ、またILベースのJITで機能するには不可欠な特徴を備えます。

型システムに対するガベージコレクタの要求事項
-------------------------------------------------

ガベージコレクタはGCヒープに割り付けられた型のインスタンスに関する情報を必要とします。
そのために、すべてのマネージドオブジェクトの先頭には型システムのデータ構造（MethodTable）へのポインターがあります。
マネージドオブジェクトにアタッチされているMethodtableとは、型のインスタンスのGCレイアウトを表現するデータ構造です。
このレイアウトには2つの形式があります（1つは通常の型、またはオブジェクト配列で、もう1つは値型の配列です）。

- **仮定:** 型システムのデータ構造は、それが表現しているマネージドオブジェクトの存続期間を超えて存続します。
- **要求:** ガベージコレクタには、ランタイムが停止している間にスタックウォーカーを実行するという要件があります。このことについて以降で論じます。

型システムに対するスタックウォーカーの要求事項
-------------------------------------------

スタックウォーカー/GCスタックウォーカーは2つのケースで型システムを入力とします。

<!-- report within の意味が取れていない。 -->
- スタック上の値型のサイズを知るため。
- スタック上の値型の中で、報告するGCルートを知るため。

様々な理由、たとえば型のロードを遅らせたいとか、コード生成で（関連するGC情報のみが異なる）複数のバージョンができてしまうのを避けたいなどの理由から、
CLRは現在、スタック上のメソッドについてシグネチャの調査（walking）を必要とします。
これが必要になる事態はめったにありません。スタックウォーカーを実行する必要が生まれるのは非常に限定された瞬間だけだからです。
しかし、わたしたちの信頼性目標を達成するには、スタックウォーキング中にシグネチャ調査が機能する必要があります。

スタックウォーカーはおおむね3通りのモードで実行されます。

- セキュリティまたは例外処理のために現在のスレッドのスタックを渡り歩く。
- GCのためにすべてのスレッドのスタックを渡り歩く（すべてのスレッドは実行エンジンによって停止されます）。
- プロファイラのために指定のスレッドのスタックを渡り歩く（当該スレッドは停止されます）。

GCのスタックウォーキングと、プロファイラのスタックウォーキングの場合は、スレッドが停止するため、メモリ割り当てやほとんどのロック獲得は安全ではありません。

そのことをきっかけとして、私たちは上記の要求に従うために信頼できる型システムの道に進んだのです。

その目標を達成するために型システムに要求される規則は次のものです。

- あるメソッドが呼び出された時には、メソッドの値型のパラメータはすべてプロセス内のどこかのアプリケーションドメインにロードされていること。
- 指定のシグネチャを持つアセンブリから、指定の型を実装しているアセンブリへのアセンブリ参照は、スタックウォークの一部としてシグネチャ調査が必要とされるまでに解決されていること。

この規則は、タイプローダー、NGENのイメージ生成プロセス、およびJITにおける、大規模で複雑な執行を通して執行されます。

<!-- a set of a set of contract violations の意味が取れていない。 -->
- **課題:** 型システムに対するスタックウォーカーの要求事項は**非常に**不安定なものです。
- **課題:** スタックウォーカーの要求を型システムにおいて実装したものは、ロードされた型の検索中に触れるかもしれない型システムのすべての機能に一連の契約違反を要求します。
- **課題:** シグネチャの調査は通常のシグネチャ調査コードによって実行されます。このコードはシグネチャを調査しながら型をロードするよう設計されていますが、この場合は型のロード機能を使いつつも、実際には型のロードが全く引き起こされないという仮定が置かれています。
- **課題:** スタックウォーカーの要求事項は、型システムからサポートされるだけではなく、アセンブリローダーからもサポートされる必要があります。ここで述べた型システムの要求に合致させるには、アセンブリローダーには多くの問題があります。

型システムとNGEN
--------------------

型システムのデータ構造群はNGENイメージに保存されるものの核となる部分です。
残念なことに、それらのデータ構造は他のNGENイメージへの論理的なポインタを持っています。
その状況に対処するために、型システムのデータ構造は復元（restoration）という概念を実装しています。

復元では、型システムのあるデータ構造が最初に必要となったときに、そのデータ構造には正しいポインターが用意されます。
この動作は、Book of the Runtimeの[タイプローダー](type-loader.md)のチャプターで説明されている、型のロードレベルと結びついています。

他に、事前復元されたデータ構造という概念もあります。
これは、NGENイメージのロード時には（モジュールをまたぐポインターの修正と、先行してロードされる型の修正が済んでおり）、そのデータ構造は十分に正しいため、その状態のまま使われることもあるということです。
この最適化は、NGENイメージが、依存先のアセンブリと「強く結びついている」ことを要求します。
詳細はNGENのドキュメントを参照してください。

型システムとドメイン中立ローディング
--------------------------------------

型システムはドメイン中立ローディングの実装における核心部分です。
これはAppDomainを生成する際のLoaderOptimizationオプションを通じて顧客に公開されます。
mscorlibは常にドメイン中立としてロードされます。 
この機能の中心的な要求事項は、型システムのデータ構造がドメイン固有の状態を参照するポインターを要求してはならないということです。
このことは主として静的フィールドやクラスのコンストラクターにまつわる要求の中に現れます。
特に、あるクラスのコンストラクターがすでに実行されているかどうかが核心のMethodTableデータ構造には含まれていないのはそのことが理由であり、
MethodTableデータ構造ではなくDomainFileデータ構造にアタッチされた静的データを保持する機構があります。

物理アーキテクチャ
=====================

型システムの主要な部分を以下に記します。

- Class.cpp/inl/h – EEClass関数群、および BuildMethodTable
- MethodTable.cpp/inl/h – メソッドテーブルを操作する関数群
- TypeDesc.cpp/inl/h – TypeDescを調べる関数群
- MetaSig.cpp SigParser – 署名コード
- FieldDesc /MethodDesc – それらのデータ構造を調べる関数群 
- Generics – ジェネリクス固有のロジック
- Array – 配列処理に必要となる特殊ケースを扱うコード
- VirtualStubDispatch.cpp/h/inl – 仮想スタブディスパッチのコード
- VirtualCallStubCpu.hpp – 仮想スタブディスパッチにおけるプロセッサー固有のコード

主要なエントリーポイントは、 BuildMethodTable, LoadTypeHandleThrowing, CanCastTo\*, GetMethodDescFromMemberDefOrRefOrSpecThrowing, GetFieldDescFromMemberRefThrowing, CompareSigs, そして VirtualCallStubManager::ResolveWorkerStatic です。

関連する読み物
===============

- [ECMA CLI 仕様](../project-docs/dotnet-standards.md)
- Book of the Runtimeの [タイプローダー](type-loader.md) のチャプター
- Book of the Runtimeの [仮想スタブディスパッチ](virtual-stub-dispatch.md) のチャプター
- Book of the Runtimeの [MethodDesc](method-descriptor.md) のチャプター
