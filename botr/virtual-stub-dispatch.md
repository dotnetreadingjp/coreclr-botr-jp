Virtual Stub Dispatch
仮想スタブディスパッチ
=====================

(これはhttps://github.com/dotnet/coreclr/blob/master/Documentation/botr/virtual-stub-dispatch.mdの日本語訳です。対象rev.は 8d3936b ）

著者：Simon Hall ([@snwbrdwndsrf](https://github.com/snwbrdwndsrf)) - 2006

はじめに
============

仮想スタブディスパッチ処理（VSD：Virtual Stub Dispatching）は、仮想メソッド呼び出しについて、伝統的な仮想メソッドテーブルの代わりにスタブを使用する技術です。過去、インターフェイスディスパッチでは、それぞれのインターフェイスがプロセス内で一意な識別子を持つことと、読み込まれたすべてのインターフェイスがグローバルなインターフェイス仮想テーブルマップに追加される必要がありました。この要件により、NGENのシナリオにおいて、すべてのインターフェイスと、インターフェイスを実装するすべてのクラスが実行時に復元されなければならないこととなり、起動時のワーキングセットを著しく増加させていました。スタブディスパッチ処理の動機は、これに関連するワーキングセットの大半を減らすことと、プロセスのライフタイム全体に残りの作業を分散させることでした。

VSDは仮想インスタンスメソッド呼び出しとインターフェイスメソッド呼び出しの両方に使用可能なのですが、現在のところインターフェイスディスパッチにのみ使用されています。

依存関係
------------

### コンポーネントの依存関係

スタブディスパッチ処理のコードはランタイムの残りの部分から比較的独立しています。スタブディスパッチ処理は依存するコンポーネントから使用できるAPIを提供しており、さらに以下に述べる依存関係は比較的小さくなっています。

#### コードマネージャー

メソッドの状態、特に、VSDがスタブ生成とターゲットキャッシュ処理のような詳細事項について判定できるようにするための、特定のメソッドが最終状態に遷移済かどうかの情報提供について、VSDは実質的にコードマネージャーに依存しています。

#### 型とメソッド

メソッドテーブルは、任意のVSDコールサイトについて、その呼び出し先コードアドレスを判定するための、ディスパッチマップへのポインターを保持します。

#### 特別な型

COM相互運用型への呼び出しは、両方から特別なターゲット解決がなされるよう、カスタムディスパッチが実行されなければなりません。

### このコンポーネントに依存するコンポーネント

#### コードマネージャー

コードマネージャーは、インターフェイス呼び出しのコールサイトターゲットをJITコンパイラに提供するにあたってVSDに依存します。

#### クラスビルダー

クラスビルダーは、型の構築中、VSDのコードが型のディスパッチで使用することになるディスパッチマップを作成するために、ディスパッチマップ処理コードによって公開されるAPIを使用します。

設計の目標と目標でないもの
--------------------------

### 目標

#### ワーキングセットの削減

インターフェイスディスパッチは、以前は、プロセス内のすべてのインターフェイス識別子を取り扱う、巨大で、少々まばらなvtableルックアップマップを使用して実装されていました。VSDの目標は、理論上は関連するコールサイトとそのディスパッチスタブが互いに隣接するようにしてワーキングセットの密度を上げるように、必要とされた都度ディスパッチスタブを生成することで、コールドワーキングセットの量を削減することでした。

ここには注意すべき重要なポイントがあります。システムの実行に従って作成され、回収される個々のスタブを追跡するために必要となるデータ構造のために、VSDがコールサイトごとに導入する初期ワーキングセットvtableの場合よりも多くなっています。ただし、これらのデータ構造は単純なディスパッチ処理には不要であるため、アプリケーションが安定的な状態に近づくにしたがってページアウトされていきます。残念ながら、クライアントアプリケーションでは、これは起動時間が遅くなることと同じことです。これは、仮想メソッドディスパッチでVSDを無効にした要因の一つです。

#### 同等なスループット

インターフェイスメソッドと仮想メソッドのディスパッチが、以前のvtableディスパッチ機構と平均的には同等であり続けることが重要でした。

インターフェイスディスパッチでこれを達成できることはすぐにわかりましたが、仮想メソッドのディスパッチは少々遅くなることが明らかになりました。これは仮想メソッドの場合にVSDを無効にした要因の一つです。

トークン表現とディスパッチマップの設計
-----------------------------------------------

ディスパッチトークンは、実行時に割り付けられる、ネイティブワードサイズの値で、内部的には、インターフェイスとスロットを表すタプルでなります。

この設計では、割り当てられた型のID値とスロット番号の組み合わせを使用します。ディスパッチトークンはこれら2つの値の組み合わせでなります。ランタイムとの統合の折り合いをつけるために、この実装では従来のvtableのレイアウトと同じ方法でスロット番号を割り当てています。つまり、この抽象構造を取り扱うために、ランタイムは直接ではなくヘルパーメソッド経由でvtableにアクセスしなければならないという点を除き、メソッドテーブル、メソッド既述子、スロット番号をvtableとまったく同じ方法で処理できます。

_スロット_ と言う用語は、常に従来のvtableのレイアウトにおけるスロットのインデックス値であり、マッピング機構によって作成および解釈されるものという文脈で使用していきます。これが何を意味するかと言うと、ランタイム内に以前実装されていた、仮想メソッドのスロットの後に非仮想メソッドのスロットが続くという従来のメソッドテーブルのレイアウトを思い描いた場合の、そのスロット番号だということです。ランタイムのコードにおいて、スロットは従来のvtable構造におけるインデックスと、vtableそのものへのポインターのアドレスの両方の意味を持つため、この違いを理解することが重要です。変更点は、スロットは今やインデックス値のみであり、コードポインターのアドレスは実装テーブル（後述）に保持されるということです。

動的割り当てられる型ID値については後述します。

### メソッドテーブル

#### 実装テーブル

これは、型によって導入される各メソッドの本体に対し、そのメソッドのエントリポイントへのポインターを保持する配列です。このテーブルのメンバーは以下の順序で配置されています。

- 導入された（新しいスロットの）仮想メソッド群。
- 導入された非仮想（インスタンスと静的）メソッド群。
- オーバーライドする仮想メソッド群。

この形式になっている理由は、これが従来型のvtableレイアウトの自然な拡張になるためです。結果として、スロットマップ（後述）の多くのエントリは、上記の順序と、クラスの仮想メソッドと非仮想メソッドの総数のようなその他の詳細事項から推論することができます。

仮想インスタンスメソッドに対するスタブディスパッチが無効な場合（現在の状態）、実装テーブルは存在しなくなり、本物のvtableによってその実体が置き換えられます。すべてのマッピング結果は、実装テーブルではなくvtable用のスロットとして表されます。本書の残りの部分で実装テーブルについて言及されているときには、このことを思い出してください。

#### スロットマップ

スロットマップは0以上の< _型_, [<_スロット_, _スコープ_, (_インデックス|テーブル_)>]>エントリのテーブルです。 _型_ は、前述の動的に割り当てられるID番号で、現在のクラスを示すための番兵値（仮想インスタンスメソッドの呼び出し）か、現在のクラスによって実装される（かその親によって暗黙的に実装される）インターフェイス用のIDです。（角カッコ内の）サブマップには、1つ以上のエントリがあります。サブマップ各エントリについて、1番目の要素は常に _型_ のスロットを示します。2 番目の要素である _スコープ_ は、3番目の要素が実装 _インデックス_ なのか _スロット_ 番号なのかを示します。 _スコープ_ は次の要素の番号が仮想スロット番号として解釈され、 _this.スロット_ として仮想的に解決されるべきことを示す既知の番兵値にできます。 _スコープ_ は現在のクラス継承階層における特定のクラスを識別することもでき、そのような場合、第3引数は _スコープ_ によって示されるクラスの実装テーブルの _インデックス_ であり、かつ _型.スロット_ に対する最終的なメソッド実装です。

#### 例

下の図は小さなクラス構造（C#によるモデル）と、その結果として生成される各クラスの実装テーブルとスロットマップがどのようなものになるかを示しています。

![Figure 1](https://github.com/dotnet/coreclr/blob/master/Documentation/images/virtualstubdispatch-fig1.png)

つまり、このマップを見ると、スロットマップのサブマップの1番目の列が、従来の仮想テーブルビューのスロット番号に対応しているのが分かります（System.Object自身が4つの仮想メソッドを提供していることを思い出してください。ただし、わかりやすくするためにそれらは省略しています）。メソッドの実装の検索は常にボトムアップです。つまり、型 _B_ のオブジェクトがあり、 _I.Foo_ を呼び出したいとすると、 _B_ のスロットマップを起点として _I.Foo_ のマッピングを探すことになります。そこで見つからないので、 _A_ のスロットマップに行って検索し、そこで見つけます。そこでは、 _I_ の仮想スロット0（ _I.Foo_ に対応します）は仮想スロット0で実装されていると記述されています。そして、 _B_ のスロットマップに戻り、スロット0の実装を検索し、B自身の実装テーブルのスロット1で実装されていることがわかります。

### さらなる使用法

このマッピングテクニックを、仮想スロットのメソッド実装再マッピングの実装に使用できる（つまり、現在のクラス用のスロットマップ内の仮想スロットマッピングは、インターフェイススロットが仮想スロットにマップされる方法によく似ている）ことに注意することが重要です。スロットマップにはスコープ設定機能があるので、非仮想メソッドも同じように参照できます。これは、ランタイムが非仮想メソッドでのインターフェイスの実装をサポートしたい場合であっても役に立つことでしょう。

### 最適化

スロットマップはビット列としてエンコードされており、差分値を使用して典型的なインターフェイス実装パターンをさばくので、スロットマップのサイズは非常に小さなものになっています。さらに、新しいスロット（仮想と非仮想の両方）は実装テーブル内の順序によって黙示されます。実装テーブルが新しい仮想スロットに続けて新しいインスタンススロット、さらにその後にオーバーライドを保持する場合、親クラスによって継承された仮想メソッドの数と実装テーブルにおけるインデックスを組み合わせることで、適切なスロットマップエントリを黙示できます。そのように暗黙的に示されるマップエントリはすべて (\*) で示されます。データ構造の現在のレイアウトは以下のパターンを使用します。ここで、ディスパッチマップ（DispatchMap）は、実装テーブルの順序ではマッピングを完全に黙示できない場合にのみ存在します。

	メソッドテーブル -> [ディスパッチマップ ->] 実装テーブル

型IDマップ
-----------

これは、型からIDへのマップです。IDは、それまでマップされていなかった型に遭遇するたびに単調増加する値として割り当てられます。現在、IDが割り当てられる型は、インターフェイスです。

現在、このマップはハッシュマップを使用して実装されており、双方向に検索するためのエントリを保持します。

ディスパッチトークン
---------------

ディスパッチトークン（Dispatch Token）は、<_型ID_, _スロット_>のタプルです。インターフェイスの場合、型IDは、その型に割り当てられたインターフェイスIDになります。仮想メソッドの場合、そのスロットが（_this_ に対する仮想メソッド呼び出しとして）単にディスパッチされる型で仮想的に解決されるべきことを示す定数値になります。この値のペアはほとんどの場合にプラットフォームのネイティブのワードサイズに収まります。x86では、それぞれの値の下位16ビットが結合されることになるでしょう。これは、ランタイムの _TypeHandle_ が _メソッドテーブル_ ポインターか、<_TypeHandle_, _TypeHandle_> のペアのいずれかになる可能性があり、番兵ビットを使用してこれら2つのケースを区別する、ということと類似の、オーバーフロー問題の処理の仕方に一般化できます。これが必要かどうかはまだ未定です。

仮想スタブディスパッチの設計
===============================

ディスパッチトークンからの実装の解決
-------------------------------------------

所与のトークンと型について、実装は、その型用の実装テーブルのインデックスにトークンをマッピングすることで見つかります。実装テーブルは型のメソッドテーブルから到達可能です。このマップはBuildMethodTableで作成されます。この関数はメソッドテーブルを構築している方によって実装されるすべてのインターフェイスを列挙し、すべてのインターフェイスメソッドについて、その型がそのメソッドを実装するのか、またはオーバーライドするのかを判定します。この情報を追跡し続けることで、インターフェイスディスパッチの実行時に、与えられたトークンとターゲットオブジェクト（メソッドテーブルとトークンマッピングの取得先になります）からターゲットのコードを判定できるのです。

スタブ
-----

インターフェイスディスパッチはスタブを通じて呼び出します。これらのスタブはすべて必要に応じて生成され、すべてがトークンとオブジェクトを実装に一致させるという最終目標を持っており、呼び出しを実装に転送します。

There are currently three types of stubs. The below diagram shows the general control flow between these stubs, and will be explained below.
現在、スタブは3種類あります。以下の図は、図の後で説明する、これらのスタブ間の一般的な制御フローを示しています。

![Figure 2](https://github.com/dotnet/coreclr/blob/master/Documentation/images/virtualstubdispatch-fig2.png)

### 汎用リゾルバー

実際のところ、汎用リゾルバー（Generic Resolver）はすべてのスタブに対する最終的な失敗パスとして提供されるCの関数にすぎません。<_トークン_, _型_> タプルを受け取り、ターゲットを返します。汎用リゾルバーは、必要な場合にディスパッチスタブと解決スタブを作成し、より適切なスタブが利用可能になった場合には間接化セル（indirection cell）をパッチングし、結果をキャッシュし、あらゆる記録処理（bookkeeping）を行う役割も持ちます。


### 検索スタブ

検索スタブ（Lookup Stub）はインターフェイスディスパッチのコールサイトに最初に割り当てられ、JITがインターフェイスのコールサイトをコンパイルするときに作成されます。JITは、最初の呼び出しが行われるまでトークンに埋め込むための型について何も知らないので、このスタブは汎用リゾルバーへの引数としてトークンと型を渡します。必要ならば、汎用リゾルバーもディスパッチスタブと解決スタブを作成し、ディスパッチスタブに向くようコールサイトにパッチを当て、検索スタブは使用されなくなります。

一意なトークンそれぞれに対して、1つの検索スタブが作成されます（つまり、同じインターフェイススロットに対するコールサイトは同じ検索スタブを使用することになります）

### ディスパッチスタブ

ディスパッチスタブ（Dispatch Stub）は、動作としてコールサイトがモノモーフィック（非多態）であると考えられる場合に使用されます。つまり、特定のコールサイトで使用されるオブジェクトが典型的には同じ型であるということです（つまり、ほとんどの場合に、呼び出し先のオブジェクトが、前回同じサイトで呼び出されたオブジェクトと同一ということです）。ディスパッチスタブは呼び出し先のオブジェクトの型（メソッドテーブル）を受け取り、キャッシュしている型と比較し、一致した場合にはキャッシュしたターゲットにジャンプします。x86において、これは一般的に「比較、条件判定失敗時ジャンプ、ターゲットへのジャンプ」というシーケンスになり、あらゆるスタブにおいて最良のパフォーマンスを提供します。スタブの型判定に失敗した場合、対応する解決スタブ（後述）にジャンプします。

一意な<_トークン_, _型_> タプルそれぞれに対して1つのディスパッチスタブが作成されますが、コールサイトの検索スタブが呼び出されたときにのみレイジーに作成されます。

### 解決スタブ

ポリモーフィック（多態）なコールサイトは、解決スタブ（Resolve Stub）によって処理されます。解決スタブは、<_トークン_, _型_>というキーのペアを使用して、グローバルキャッシュ内のターゲットを解決します。ここで、_トークン_ はJIT時に既知であり、_型_ は呼び出し時に決定されます。グローバルキャッシュに一致するものがない場合、解決スタブの最終ステップは汎用リゾルバーを呼び出し、そこから返されたターゲットにジャンプします。汎用リゾルバーが <_トークン_, _型_, _ターゲット_> というタプルをグローバルキャッシュに挿入することになるため、同じ<_トークン_, _型_>タプルを使用した後続の呼び出しは、グローバルキャッシュでターゲットを見つけられるようになります。

ディスパッチスタブが一定頻度以上失敗すると、コールサイトはポリモーフィックであると見なされ、継続的なディスパッチスタブの失敗によるオーバーヘッドを避けるために、解決スタブはコールサイトが解決スタブを直接指し示すようにパッチを当てます。コールサイトのポリモーフィック特性は一般的に一時的なものであるという仮定の下、同期ポイント（現在のところGCの終了時）において、ポリモーフィックなコールサイトはランダムにモノモーフィックコールサイトに戻されます。特定のコールサイトについてこの仮定が誤っている場合、再びポリモーフィックに降格する戻しパッチが速やかに起動されます。

トークンごとに1つの解決スタブが作成されますが、解決スタブはすべて1つのグローバルキャッシュを使用します。トークンごとにスタブが存在することで、<_トークン_, _型_>タプルの不変のコンポーネントから事前計算したハッシュを使用して、高速かつ効果的なハッシュ処理アルゴリズムを使用できます。

### コードのシーケンス

先ほどのインターフェイス仮想テーブルディスパッチ機構は、以下のようなコードシーケンスになります。

![Figure 3](https://github.com/dotnet/coreclr/blob/master/Documentation/images/virtualstubdispatch-fig3.png)

そして、典型的なスタブディスパッチのシーケンスは以下のとおりです。

![Figure 1](https://github.com/dotnet/coreclr/blob/master/Documentation/images/virtualstubdispatch-fig4.png)

ここで、expectedMT、failure、targetはスタブにエンコードされた定数値です。

典型的なスタブシーケンスの命令数は以前のインターフェイスディスパッチ機構と同じで、メモリ間接が少なくなることによるワーキングセットの使用量が減少するので、実行は高速化されることでしょう。同様に、コールサイトではなくスタブで処理の大半が行われるため、JIT後のコードはより小さくなります。これは、コールサイトがめったに呼び出されない場合の唯一の利点です。x86の分岐予測が成功ケースに従うように失敗分岐が配置されていることに注意してください。

現在の状態
=============

現在はVSDはインターフェイスメソッド呼び出しでのみ有効になっており、仮想インスタンスメソッド呼び出しでは有効になっていません。これにはいくつかの理由がありました。

- **起動：** 大量の初期スタブを生成する必要があるために、起動時のワーキングセットとスピードの障害となります。
- **スループット：** インターフェイスディスパッチは、一般的にVSDによって高速化しますが、仮想インスタンスメソッド呼び出しでは許容できないスピードの劣化が発生します。

仮想インスタンスメソッド呼び出しでVSDを無効化した結果として、すべての型が仮想インスタンスメソッド用のvtableを保持し、前述の実装テーブルは無効になります。インターフェイスメソッドのディスパッチ処理を有効にするために、ディスパッチマップは存在しています。

物理アーキテクチャ
=====================

ディスパッチトークンとディスパッチマップの実装詳細については、[clr/src/vm/contractImpl.h](https://github.com/dotnet/coreclr/blob/master/src/vm/contractimpl.h)と[clr/src/vm/contractImpl.cpp](https://github.com/dotnet/coreclr/blob/master/src/vm/contractimpl.cpp)を参照してください。

[clr/src/vm/virtualcallstub.h](https://github.com/dotnet/coreclr/blob/master/src/vm/virtualcallstub.h) and [clr/src/vm/virtualcallstub.cpp](https://github.com/dotnet/coreclr/blob/master/src/vm/virtualcallstub.cpp).
仮想スタブディスパッチの実装詳細については、[clr/src/vm/virtualcallstub.h](https://github.com/dotnet/coreclr/blob/master/src/vm/virtualcallstub.h)と[clr/src/vm/virtualcallstub.cpp](https://github.com/dotnet/coreclr/blob/master/src/vm/virtualcallstub.cpp)を参照してください。
